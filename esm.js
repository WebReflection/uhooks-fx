let e=null,t=new Set;const n=e=>{const{$:t,r:n,h:s}=e;i(n)&&(l.get(s).delete(e),n()),i(e.r=t())&&l.get(s).add(e)},s=()=>{const e=t;t=new Set,e.forEach((({h:e,c:t,a:n,e:s})=>{s&&e.apply(t,n)}))},l=new WeakMap,r=[],c=[];function o(e,t){return e!==this[t]}const a=e=>{const t=l.get(e);t&&d.then((()=>{t.forEach((e=>{e.r(),e.r=null,e.d=!0})),t.clear()}))},h=()=>e,u=e=>l.has(e),i=e=>"function"==typeof e,p=t=>{const s={h:l,c:null,a:null,e:0,i:0,s:[]};return l;function l(){const l=e;e=s,s.e=s.i=0;try{return t.apply(s.c=this,s.a=arguments)}finally{e=l,r.length&&d.then(r.forEach.bind(r.splice(0),n)),c.length&&c.splice(0).forEach(n)}}},d=Promise.resolve(),f=e=>({_:new Set,provide:y,value:e}),g=({_:e,value:t})=>(e.add(h()),t);function y(e){const{_:t,value:n}=this;n!==e&&(this._=new Set,this.value=e,t.forEach((({h:e,c:t,a:n})=>{e.apply(t,n)})))}const $=(e,t)=>_((()=>e),t),_=(e,t)=>{const n=h(),{i:s,s:l}=n;return s!==l.length&&t&&!t.some(o,l[s]._)||(l[s]={$:e(),_:t}),l[n.i++].$},w=e=>(t,n)=>{const s=h(),{i:r,s:c,h:a}=s,u=r===c.length;s.i++,u&&(l.has(a)||l.set(a,new Set),c[r]={$:t,_:n,r:null,d:!1,h:a}),(u||!n||c[r].d||n.some(o,c[r]._))&&e.push(c[r]),c[r].$=t,c[r]._=n,c[r].d=!1},v=w(r),E=w(c),S=(e,t)=>i(t)?t(e):t,k=(e,n,l)=>{const r=h(),{i:c,s:o}=r;c===o.length&&o.push({$:i(l)?l(n):S(void 0,n),set:n=>{o[c].$=e(o[c].$,n),(e=>{t.has(e)||(e.e=1,t.add(e),d.then(s))})(r)}});const{$:a,set:u}=o[r.i++];return[a,u]},m=e=>{const t=h(),{i:n,s:s}=t;return n===s.length&&s.push({current:e}),s[t.i++]};
/*! (c) Andrea Giammarchi - ISC */
let M=null,W=null,b=null;const x=new WeakMap,P=new WeakMap,j=(e,t,n,s)=>{const l=l=>{x.has(e)||(x.set(e,0),d.then((()=>{x.delete(e),e.apply(t,n)}))),s(l)};return P.set(s,l),l},q=(e,t,n,s)=>e?[s[0],P.get(s[1])||j(e,t,n,s[1])]:s,z=(e,t)=>{const n=p(t?function(){const[t,s,l]=[M,W,b];[M,W,b]=[n,this,arguments];try{return e.apply(W,b)}finally{[M,W,b]=[t,s,l]}}:e);return n},A=(e,t,n)=>q(M,W,b,k(e,t,n)),B=e=>q(M,W,b,(e=>k(S,e))(e));export{f as createContext,a as dropEffect,u as hasEffect,z as hooked,$ as useCallback,g as useContext,v as useEffect,E as useLayoutEffect,_ as useMemo,A as useReducer,m as useRef,B as useState,d as wait};
