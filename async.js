self.uhooksFX=function(e){"use strict";var t=Promise;let n=null,s=new Set;const a=e=>{const{$:t,r:n,h:s}=e;i(n)&&(r.get(s).delete(e),n()),i(e.r=t())&&r.get(s).add(e)},c=()=>{const e=s;s=new Set,e.forEach((({h:e,c:t,a:n,e:s})=>{s&&e.apply(t,n)}))},r=new WeakMap,u=[],o=[];function l(e,t){return e!==this[t]}const h=()=>n,i=e=>"function"==typeof e,f=e=>{const t={h:s,c:null,a:null,e:0,i:0,s:[]};return s;function s(){const s=n;n=t,t.e=t.i=0;try{return e.apply(t.c=this,t.a=arguments)}finally{n=s,u.length&&p.then(u.forEach.bind(u.splice(0),a)),o.length&&o.splice(0).forEach(a)}}},p=new t((e=>e()));function d(e){const{_:t,value:n}=this;n!==e&&(this._=new Set,this.value=e,t.forEach((({h:e,c:t,a:n})=>{e.apply(t,n)})))}const y=(e,t)=>{const n=h(),{i:s,s:a}=n;return s!==a.length&&t&&!t.some(l,a[s]._)||(a[s]={$:e(),_:t}),a[n.i++].$},w=e=>(t,n)=>{const s=h(),{i:a,s:c,h:u}=s,o=a===c.length;s.i++,o&&(r.has(u)||r.set(u,new Set),c[a]={$:t,_:n,r:null,h:u}),(o||!n||n.some(l,c[a]._))&&e.push(c[a]),c[a].$=t,c[a]._=n},g=w(u),E=w(o),$=(e,t)=>i(t)?t(e):t,_=(e,t,n)=>{const a=h(),{i:r,s:u}=a;r===u.length&&u.push({$:i(n)?n(t):$(void 0,t),set:t=>{u[r].$=e(u[r].$,t),(e=>{s.has(e)||(e.e=1,s.add(e),p.then(c))})(a)}});const{$:o,set:l}=u[a.i++];return[o,l]},v=new WeakMap,k=e=>{const t=f(e);return v.set(n,t),n;async function n(){return await t.apply(this,arguments)}};
/*! (c) Andrea Giammarchi - ISC */
let S=null,M=null,m=null;const W=new WeakMap,C=new WeakMap,b=(e,t,n,s)=>{const a=a=>{W.has(e)||(W.set(e,0),p.then((()=>{W.delete(e),e.apply(t,n)}))),s(a)};return C.set(s,a),a},x=(e,t,n,s)=>e?[s[0],C.get(s[1])||b(e,t,n,s[1])]:s;return e.createContext=e=>({_:new Set,provide:d,value:e}),e.dropEffect=e=>(e=>{const t=r.get(e);t&&p.then((()=>{t.forEach((e=>{e.r(),e.r=null})),t.clear()}))})(v.get(e)),e.hasEffect=e=>(e=>r.has(e))(v.get(e)),e.hooked=(e,t)=>{const n=k(t?async function(){const[t,s,a]=[S,M,m];[S,M,m]=[n,this,arguments];try{return await e.apply(M,m)}finally{[S,M,m]=[t,s,a]}}:e);return n},e.useCallback=(e,t)=>y((()=>e),t),e.useContext=({_:e,value:t})=>(e.add(h()),t),e.useEffect=g,e.useLayoutEffect=E,e.useMemo=y,e.useReducer=(e,t,n)=>x(S,M,m,_(e,t,n)),e.useRef=e=>{const t=h(),{i:n,s:s}=t;return n===s.length&&s.push({current:e}),s[t.i++]},e.useState=e=>x(S,M,m,(e=>_($,e))(e)),e.wait=p,e}({});
